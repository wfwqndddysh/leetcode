搜索策略的选择 优化 与实现

atombomb

在acm  的竞赛中 搜索是一个重要的考察方面 ，在历年的比赛中都有相当数量着这类试题。
在经过一段时间的研究和整理之后 总结了一些经验 希望起到抛砖引玉的作用

在这篇文章中 你将看到的是 : 常见的搜索形式与选择，各种搜索的常见优化与实现，搜索算法的一些变种，

一．竞赛中常见的搜索形式

在acm 竞赛中的搜索主要可以分为 经典搜索 ，和类搜索 (姑且让我这样称呼，
这些搜索有时可能已经不能算是真正的搜索算法了 但是却采用了 一些搜索的框架，模型，或思想，在搜索算法的变种中，会介绍一些这样的算法)

经典搜索 目前指的主要还是 深度优先搜索 和 广度优先搜索

1．首先介绍一下 深度优先搜索 深度优先搜索 （DFS） 可以算是在acm 竞赛中 使用最多的算法了 有时可以是一个简单的 全排列，
全组合的生成函数 可有时也可以是一整道难题，这就造成了 dfs 没有一个十分明确的固定形式 变化极其多样。但是总的来说 dfs 一般是基于这样的一个形式

void dfs(nowstate)
{
    if （nowstate == goalstate）   得到可行解
    else if (nowstate 的所有子状态 均为不可行解) return;

    set allnextstate={ 所有由当前nowstate 生成的nextstate}；
    for (int i=0;i<allnextstate.size;i++)
        dfs(allnextstate[i]); 进入下一状态
}

这里的nowstate 可以是一个参数 也可以是多个不同参数 也可以是一个复合数据类型 总之这些数据要能够要能完全表示对于问题的一种状态的所有信息，
而下面的nextstate 一般也和nowstate 有着同样的数据结构。上面的allnextstate 可以看成一个集合 每个元素为由当前状态可以生成的下个状态 
但是这并不表示我们需要将他们一次性的全部生成，实际上在更多的情况下，我们生成一个 拓展一个。 这里还有一个初学者需要值得注意的问题就是
在每拓展一个状态的一个子状态之后，在拓展它的下一个子状态之前 我们有可能需要调整一些全局变量的值  使这些辅助的状态变量 恢复到扩展前一个状态前的值。
而当我们通过一定的计算或推理发现一个状态的所有子状态一定都为不可行解时我们就没有任何理由去拓展这个状态，通过这样的操作我们就可以实现剪枝了，这也是dfs 中的重要优化。

2．除了dfs 之外，广度优先搜索（bfs）也是搜索算法的重要组成部分，与dfs 相比bfs 可以看成是对状态树的层次遍历求解，而这一特性 也注定了bfs 与dfs 的巨大差异

在BFS 中我们需要创建一个队列以保存所有的待扩展节点，而不是像BFS 那样只需要保存当前状态即可，这样就使BFS 比DFS 需要占用更多的空间，常常是成指数级增长的，
但由于BFS是按层次遍历的一般来说能比DFS  更快的找到解，因为它找到的第一个可行解一般来说都是最优解，而无需像DFS 那样进行回朔。这里我们可以看出在程序的算法中时间复杂度 和空间复杂度通常是对立的，

       一般来说 bfs也可以有这样的一个模式;


queue<statestruct> qq;
qq.push_back(start);
while (!qq.empty)
{
    nowstate=qq.front;
    set allnextstate={ 所有由当前nowstate 生成的nextstate};
    for (int i=0;i<allnextstate.size;i++)
    {
        if (nextstate 不在 队列qq中时)
            qq.push_back(nextstate);
    }
    qq.pop_front;
}

在上面的伪代码中statestruct 为用来储存一个状态的数据结构，qq 为储存待扩展状态的循环队列。
当我们想将一个新的状态加入队列时 我们需要检查它在队列中否出现过，这样的步骤是必需的，
不然会使我们已经捉襟见肘的储存空间更加紧张，一般来说这是难以承受的。与DFS 相比 BFS的变化相对较少， 
一般它的难点在于空间复杂度上，需要处理一些诸如 状态表示 状态规模压缩 的工作，而BFS需要处理的一般则是时间复杂度上的问题，
通常需要有比较好的剪枝策略，才能获得比较满意的效果。

所以我们在考虑使用何种搜索算法时，如果要采用DFS 就需要仔细计算和分析状态的规模，
规模空间要在空间的允许范围内，而状态数量则要在时间的允许范围内。对于想采用BFS的问题我们主要考虑 状态的数量，
并需要想方设法的减少这一数字。一般来说 BFS  主要针对哪个状态层次明显的求最优解问题。而DFS着针对一些层次感不明显，或是状态无序的问题。


回溯，搜索浅析
http://hongweiyi.com/2012/02/algorithm-search/

